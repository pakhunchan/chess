# Backend Plan — Solo vs Computer (Random Legal Moves)

## 1. Goal & Scope (Phase 1)

Build a backend service that supports:
- A **single human player vs a computer opponent**
- The computer selects **random legal moves**
- The backend is the **sole authority** on game state and move legality
- No authentication, multiplayer, or real-time sockets yet

This phase focuses on:
- Validating chess moves
- Persisting game state
- Detecting game-ending conditions
- Preparing the architecture for stronger AI and multiplayer later

---

## 2. Tech Stack

- **Language**: Python 3.11+
- **Web Framework**: FastAPI
- **Database**: PostgreSQL
- **ORM**: SQLAlchemy or SQLModel
- **Chess Rules Engine**: python-chess (used strictly as a rules engine)
- **Server**: Uvicorn

---

## 3. Core Architectural Principles

1. **Server-authoritative chess**
   - Clients never decide whether a move is legal.
2. **Deterministic game state**
   - The board is represented by a canonical position snapshot.
3. **Stateless API calls**
   - Each request reconstructs state from persisted data.
4. **Isolated AI logic**
   - Computer move selection is handled in a dedicated service.

---

## 4. Chess State Representation

### Board State Format
- Store the board using a **single-string canonical snapshot** that encodes:
  - Piece placement
  - Side to move
  - Castling rights
  - En passant availability
  - Move counters (for draw rules)

### Why store snapshots
- Instant game resume
- Easy debugging and replay
- No need to replay all moves on each request
- Industry-standard approach

---

## 5. Database Design (PostgreSQL)

### `games` table

Stores the authoritative current state of a game.

| Column            | Type      | Notes                                      |
|------------------|-----------|--------------------------------------------|
| id               | UUID (PK) | Generated by backend                       |
| status           | TEXT      | `active`, `finished`                       |
| current_position | TEXT      | Canonical board snapshot                   |
| turn             | TEXT      | `white` or `black`                         |
| result           | TEXT      | `white_win`, `black_win`, `draw`, `null`   |
| created_at       | TIMESTAMP |                                            |
| updated_at       | TIMESTAMP |                                            |

---

### `moves` table

Stores the move history for replay, debugging, and future analysis.

| Column          | Type        | Notes                                   |
|----------------|-------------|-----------------------------------------|
| id             | BIGSERIAL   | Primary key                             |
| game_id        | UUID (FK)   | References `games.id`                   |
| move_number    | INTEGER     | Incrementing per game                   |
| move_input     | TEXT        | Client-submitted move (e.g. `e2e4`)     |
| move_notation  | TEXT        | Optional human-readable notation        |
| position_after | TEXT        | Board snapshot after the move           |
| created_at     | TIMESTAMP   |                                         |

---

## 6. Chess Rules & Validation

The chess library is used **only as a rules engine**.

### Intended responsibilities
- Initialize a board from the stored position snapshot
- Validate whether a submitted move is legal
- Apply a move to the board
- Generate all legal moves for the computer player
- Detect:
  - Checkmate
  - Stalemate
  - Basic draw conditions

### Constraints
- Do not reimplement chess rules manually.
- Treat the library as the single authority on legality.
- Avoid reliance on undocumented or experimental features.

---

## 7. AI Behavior (Computer Player)

### Phase 1 AI
- The computer selects **one random legal move** from the current position.
- No evaluation or search logic.

### Move flow
1. Human submits a legal move
2. Backend applies the move
3. Backend checks for game-ending conditions
4. If the game is still active:
   - Generate all legal moves for the computer
   - Randomly select one
   - Apply and persist the move

> The computer move is triggered automatically as part of move submission.

---

## 8. API Design (REST)

This API follows standard REST conventions:

- **POST** endpoints are used to mutate game state.
- **GET** endpoints are used to retrieve the authoritative game state.
- The backend is the single source of truth for move legality and game outcomes.

---

### 8.1 Create a New Game

**POST** `/games`

Creates a new solo vs computer game with the initial board position.

**Behavior:**

- Initializes a new game record.
- Sets the starting board position.
- Sets the turn to white.
- Marks the game as active.

**Response Example:**

{
  "game_id": "uuid",
  "current_position": "...",
  "turn": "white",
  "status": "active",
  "result": null
}

---

### 8.2 Get Game State

**GET** `/games/{game_id}`

Returns the authoritative state of the game.

**Use Cases:**

- Initial page load.
- Page refresh or reconnect.
- Client-side state reconciliation.
- Debugging.
- Future spectator or multiplayer support.

**Response Example:**

{
  "game_id": "uuid",
  "status": "active",
  "turn": "white",
  "result": null,
  "current_position": "...",
  "moves": [
    {
      "move_number": 1,
      "move": "e2e4"
    }
  ]
}

**Field Descriptions:**

- **status:** Indicates whether the game can accept new moves (`active`, `finished`).
- **result:** Indicates the outcome once the game has ended (`white_win`, `black_win`, `draw`), otherwise `null`.
- **current_position:** Canonical board snapshot representing the full game state.
- **moves:** Ordered list of moves played so far.

---

### 8.3 Submit a Move

**POST** `/games/{game_id}/move`

Submits a human move and triggers the computer response if applicable.

**Request Example:**

{
  "move": "e2e4"
}

**Backend Processing Flow:**

1. Load the game record and current board position.
2. Reconstruct the board from the stored position snapshot.
3. Validate that the submitted move is legal.
4. Apply and persist the human move.
5. Check for game-ending conditions.
6. If the game is still active:
   - Generate all legal moves for the computer.
   - Randomly select one legal move.
   - Apply and persist the computer move.
7. Return the updated game state.

**Response Example:**

{
  "status": "active",
  "turn": "white",
  "result": null,
  "current_position": "...",
  "last_moves": ["e2e4", "e7e5"]
}

**Response Notes:**

- `last_moves` contains the human move followed by the computer move (if one was made).
- If the human move ends the game, no computer move is generated.
- If the computer move ends the game, `status` is set to `finished` and `result` is populated.

---

### 8.4 Error Handling (High-Level)

- **400 Bad Request** — Invalid or malformed move input.  
- **404 Not Found** — Game does not exist.  
- **409 Conflict** — Move submitted for a finished game.  
- **422 Unprocessable Entity** — Illegal move according to chess rules.  

All error responses should include a clear, human-readable message.
